_Functional programming in Scala_

# Введение в функциональное программирование. Функции и вычисления.

## Описание
* **В узком смысле** функциональный язык — тот, что не содержит изменяемые переменные, присваивания и императивные управляющие структуры (Pure Lisp, XSLT, XPath, XQuery, FP, Haskell (Without I/O Monad or UnsafePerformIO))
* **В широком смысле** — позволяет строить более элегантные программы с фокусом на функции, то есть таковые являются объектами. (Lisp, Scheme, Racket, Clojure, SML, Ocaml, F#, Haskell, Scala, Smalltalk, Ruby)
	* Их можно определить где угодно, передавать как аргументы и прочее

## Почему функциональное программирование?
1. Лучшая модульность
2. Лучшая параллельность и облачные вычисления
3. Можно лучше описать программу

# Начинаем
REPL — интерактивная среда.

```bash
scala   # :quit to quit
```
То же самое

```bash
sbt console
```
## Как происходит вычисление?

* Вычисление выражения
	* Берем самый левый оператор
	* Вычисляем его операнды
	* Применяем оператор к операндам
* Имя вычисляется _заменой его правой частью его определения_.
* Вычисление заканчивается, когда выражение оказывается _значением_ (например, числом).

 _Пример_:
 (2 * pi) * radius -> (2 * 3.1415) * radius -> 6.283 * radius -> result

 Определения могут содержать параметры, например

```scala
def square(x: Double) = x * x

square(2)
square(5 + 4)
square(square(2))
```

Тип параметра идет после имени параметра. После списка параметров можно указать тип возвращаемого значения

```scala
def power(x: Double, y: Int): Double: ...
```
* `Int` — 32-bit
* `Double` — 64-bit
* `Boolean`

### Call-by-value strategy

* Вычисление всех параметров функции слева направо
* Замена вызова функции правым значением определения функции с _одновременной_ заменой всех параметров функции вычисленными значениями

_Пример_: 

* `sumOfSquares(3, 2+2)`
* `sumOfSquares(3, 4)`
* `square(3) + square(4)`
* `3 * 3 + square(4)`
* `9 + square(4)`
* `9 + 4 * 4`
* `9 + 16`
* `25`

Эта модель редуцирует _выражение_ в _значение_.

**Важно**: данная модель может быть применена только к выражениям без побочных эффектов (side effects). Пример такого эффекта (в C)

```C
val++
```

Мы не можем редуцировать это выражение в значение, то есть мы не можем использовать эту модель. 

**Вопрос**: каждое ли выражение редуцируется в значение за конечное количество шагов?

**Ответ**: Нет

```scala
def loop: Int = loop
```

### Call-by-name strategy

_Пример_: 

Сначала заменяем имя на правую часть определения, а затем вычисляем выражение.

* `sumOfSquares(3, 2+2)`
* `square(3) + square(2+2)`
* `3 * 3 + square(2+2)`
* `9 + square(2+2)`
* `9 + (2+2) * (2+2)`
* `9 + 4 * (2+2)`
* `9 + 4 * 4`
* `...`

### Свойства стратегий

**Теорема**: обе стратегии редуцируются к одному значению если выражение состоит только из чистых функций и оба вычисления останавливаются за конечное число шагов.

**Теорема**: Если CBV стратегия для выражения останавливается, то CBN также останавливается. Обратное не верно.

_Пример_

```scala
def first(x: Int, y: Int) = x

first(loop)
```
В примере сверху CBN остановится, тогда как CBV — нет.

В Scala используется Call-by-Value по умлочанию. Если тип параметра функции начинается `=>`, тогда используется CBN

```scala
def constOne(x: Int, y => Int) = 1
```

## Определение условий (conditions)

`if-else` в Scala являются выражениями

```scala
def abs(x: Int) = if (x >= 0) x else -x
```

`z >= 0` — _предикат_, который имеет тип `Boolean`. `true, false, !, ||, &&`. Определение предиката через substitution model. Отметим, что иногда мы можем не вычислять правую часть предиката.

* `!true --> false`
* `!false --> true`
* `true && e --> e`
* `false && e --> false`
* `true || e -> true`
* `false || e --> e` 

## Определение значений (values)

Значения параметров функций могут быть переданы по имени или по значению. Такой же подход можно применить к определениям. 

* Форма `def` соответствует Call-by-Name, то есть правая часть вычисляется каждый раз при подстановке, то есть имя соответствует _выражению_.
* Форма `val` есть Call-by-Value, его значение вычисляется в месте определения, то есть после этого имя соответствует _значению_.

_Пример_:

```scala
val x = 5
val y = square(x)
```

`y` здесь относится к `25` а не к `square(5)` или `square(x)`.

_Еще один пример_:

```scala
def loop: Boolean = loop

def x = loop // OK
def y = loop // not OK
```

## Скоупы
 
 _Пример. Квадратный корень. Метод Ньютона._

```scala
def sqrtIter(guess: Double, x: Double): Double =
	if (isGoodEnough(guess, x)) guess
	else sqrtIter(improve(guess, x), x)

def improve(guess: Double, x: Double) =	(guess + x / guess) / 2def isGoodEnough(guess: Double, x: Double) =	abs(guess * guess - x) / x < 0.001
```

Функции `isGoodEnough` и `improve` нужны только для реализации `sqrtIter`. Для того чтобы делать имена недоступными для внешнего мира, можно помещать функции внутри других функций.

```scala
def sqrt(x: Double): Double = {

	def sqrtIter(guess: Double, x: Double): Double =
		if (isGoodEnough(guess, x)) guess
		else sqrtIter(improve(guess, x), x)
	
	def improve(guess: Double, x: Double) =		(guess + x / guess) / 2	def isGoodEnough(guess: Double, x: Double) =		abs(guess * guess - x) / x < 0.001
		
	sqrtIter(1.0, x)	
}
``` 

**Блок** ограничен `{ ... }`, он содержит последовательность определений и выражений, последнее выражение формирует возвращаемое значение блока. Блок также _является выражением_. Два простых правила для блоков:

* Определения в блоке видны только внутри блока
* Определения внутри блока переопределяют внешнее определение.

```scala
val x = 0
def f(y: Int) = y + 1
val result = {
	val x = f(3)
	x * x
} + x  # the result is 16 + 0 = 16
```

Поэтому мы можем избавиться от лишних параметров в `sqrt`:

```scala
def sqrt(x: Double): Double = {

	def sqrtIter(guess: Double): Double =
		if (isGoodEnough(guess, x)) guess
		else sqrtIter(improve(guess, x), x)
	
	def improve(guess: Double) =		(guess + x / guess) / 2	def isGoodEnough(guess: Double) =		abs(guess * guess - x) / x < 0.001
		
	sqrtIter(1.0, x)	
}
``` 

## Хвостовая рекурсия

Случай когда 

```
f(x_1...x_n) = B; B = ... f(v_1...v_n)
```

_Пример. Наибольший общий делитель._

```scala
def gcd(a: Int, b: Int): Int = 
	if (b == 0) a else gcd(b, a % b)
```
Как оно вычисляется?

* `gcd(14, 21)`
* `if (21 == 0) 14 else gcd(21, 14 % 21)`
* `if (false) 14 else gcd(21, 14 % 21)`
* `gcd(21, 14 % 21)`
* `gcd(21, 14)`
* `if (14 == 0) 21 else gcd(14, 21 % 14)`
* `if (false) 21 else gcd(14, 21 % 14)`
* `gcd(14, 21 % 14)`
* `gcd(14, 7)`
* `if (7 == 0) 14 else gcd(7, 14 % 7)`
* `if (false) 14 else gcd(7, 14 % 7)`
* `gcd(7, 14 % 7)`
* `gcd(7, 0)`
* `...`
* `7`

_Другой пример_

```scala
def factorial(n: Int): Int = 
	if (n == 0) 1 else n * factorial(n - 1)
```

Как вычисляется?

* `factorial(5)`
* `...`
* `5 * factorial(4)`
* `5 * (4 * factorial(3))`
* `...`
* `5 * (4 * (3 * (2 * (1 * 1))))`

 В первом случае последовательность сворачиваний каждый раз приводит нас к вызову `gcd(..., ...)`, тогда как во втором случае такого не происходит. В случае факториала выражение становится все больше с каждым шагом. Это различие имеет прямое отношение к исполнению этих вызовов на компьютере. 
 
 Оказывается, что если функция вызывает _себя_ в виде последнего действия, стек функции может быть использован заново. Это называется _хвостовой рекурсией_(tail recursion). Функции с хвостовой рекурсии являются итеративными, то есть являются формой `for`'а.
 
 Более общее утверждение: если последним действием ффункция вызывает любую функцию, то стек может быть испольщован для обеих функций. Такие вызовы называются _хвостовыми_ (tail calls).



_Functional programming in Scala_

# Введение в функциональное программирование

## Описание
* **В узком смысле** функциональный язык — тот, что не содержит изменяемые переменные, присваивания и императивные управляющие структуры (Pure Lisp, XSLT, XPath, XQuery, FP, Haskell (Without I/O Monad or UnsafePerformIO))
* **В широком смысле** — позволяет строить более элегантные программы с фокусом на функции, то есть таковые являются объектами. (Lisp, Scheme, Racket, Clojure, SML, Ocaml, F#, Haskell, Scala, Smalltalk, Ruby)
	* Их можно определить где угодно, передавать как аргументы и прочее

## Почему функциональное программирование?
1. Лучшая модульность
2. Лучшая параллельность и облачные вычисления
3. Можно лучше описать программу

# Начинаем
REPL — интерактивная среда.

```bash
scala   # :quit to quit
```
То же самое

```bash
sbt console
```
## Как происходит вычисление?

* Вычисление выражения
	* Берем самый левый оператор
	* Вычисляем его операнды
	* Применяем оператор к операндам
* Имя вычисляется _заменой его правой частью его определения_.
* Вычисление заканчивается, когда выражение оказывается _значением_ (например, числом).

 _Пример_:
 (2 * pi) * radius -> (2 * 3.1415) * radius -> 6.283 * radius -> result

 Определения могут содержать параметры, например

```scala
def square(x: Double) = x * x

square(2)
square(5 + 4)
square(square(2))
```

Тип параметра идет после имени параметра. После списка параметров можно указать тип возвращаемого значения

```scala
def power(x: Double, y: Int): Double: ...
```
* `Int` — 32-bit
* `Double` — 64-bit
* `Boolean`

### Call-by-value strategy

* Вычисление всех параметров функции слева направо
* Замена вызова функции правым значением определения функции с _одновременной_ заменой всех параметров функции вычисленными значениями

_Пример_: 

* `sumOfSquares(3, 2+2)`
* `sumOfSquares(3, 4)`
* `square(3) + square(4)`
* `3 * 3 + square(4)`
* `9 + square(4)`
* `9 + 4 * 4`
* `9 + 16`
* `25`

Эта модель редуцирует _выражение_ в _значение_.

**Важно**: данная модель может быть применена только к выражениям без побочных эффектов (side effects). Пример такого эффекта (в C)

```C
val++
```

Мы не можем редуцировать это выражение в значение, то есть мы не можем использовать эту модель. 

**Вопрос**: каждое ли выражение редуцируется в значение за конечное количество шагов?

**Ответ**: Нет

```scala
def loop: Int = loop
```

### Call-by-name strategy

_Пример_: 

Сначала заменяем имя на правую часть определения, а затем вычисляем выражение.

* `sumOfSquares(3, 2+2)`
* `square(3) + square(2+2)`
* `3 * 3 + square(2+2)`
* `9 + square(2+2)`
* `9 + (2+2) * (2+2)`
* `9 + 4 * (2+2)`
* `9 + 4 * 4`
* `...`

### Свойства стратегий

**Теорема**: обе стратегии редуцируются к одному значению если выражение состоит только из чистых функций и оба вычисления останавливаются за конечное число шагов.

**Теорема**: Если CBV стратегия для выражения останавливается, то CBN также останавливается. Обратное не верно.

_Пример_

```scala
def first(x: Int, y: Int) = x

first(loop)
```
В примере сверху CBN остановится, тогда как CBV — нет.

В Scala используется Call-by-Value по умлочанию. Если тип параметра функции начинается `=>`, тогда используется CBN

```scala
def constOne(x: Int, y => Int) = 1
```

## Определение условий (conditions)

`if-else` в Scala являются выражениями

```scala
def abs(x: Int) = if (x >= 0) x else -x
```

`z >= 0` — _предикат_, который имеет тип `Boolean`. `true, false, !, ||, &&`. Определение предиката через substitution model. Отметим, что иногда мы можем не вычислять правую часть предиката.

* `!true --> false`
* `!false --> true`
* `true && e --> e`
* `false && e --> false`
* `true || e -> true`
* `false || e --> e` 

## Определение значений (values)

Значения параметров функций могут быть переданы по имени или по значению. Такой же подход можно применить к определениям. 

* Форма `def` соответствует Call-by-Name, то есть правая часть вычисляется каждый раз при подстановке, то есть имя соответствует _выражению_.
* Форма `val` есть Call-by-Value, его значение вычисляется в месте определения, то есть после этого имя соответствует _значению_.
* 
